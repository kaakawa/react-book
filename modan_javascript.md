# テンプレート文字列

テンプレート文字列は、文字列の中で変数を展開するための新しい記法です。例えば従来の書き方では文字列と変数を結合する場合、以下のように＋を使用していました。

例：従来の文字列と変数の結合方法
//名前を格納した変数
const name = "田中";

//年齢を格納した変数
const age = "24";

//私の名前は田中です。年齢は 24 才です。と表示したい場合
const message = "私の名前は"　+ name + "です。年齢は" + age + "才です。";

console.log("message"); //私の名前は田中です。年齢は２４才です。

この場合、文字列結合の度に＋を書く必要があるため、読みづらく書くのも面倒くさいという問題がありました。ES2015 以降ではテンプレート文字列を用いて以下のようによりスマートに記述することができるようになりました。

例：テンプレート文字列の利用
//名前を格納した変数
const name = "田中";

//年齢を格納した変数
const age = "24";

//私の名前は田中です。年齢は２４才です。と表示したい場合
const message = `私の名前は${name}です。年齢は${age}です。`;

console.log(message) //私の名前は田中です。年齢は２４才です。

テンプレート文字列を使用する場合は`(バッククォート)で文字列を囲みます。一般的な日本語配列のキーボードであれば Shift キーと@マークのキーを押すことで入力できます。バッククォートで囲んだ場合、普通の'(シングルクォート)や"(ダブルクォート)と違い、${}(ドルマークと波括弧)で囲んだ中はJavascriptを書くことができます。そのため上記のように${name}とするだけで文字列の中で簡単に変数を展開することが可能となります。
また、使用するケースは少ないと思いますが、Javascript を書いていけるということは以下のように関数を実行したり、計算式を入れることも可能です。

例：関数の呼び出しと実行
//こんにちは！と返すだけの関数
function sayHallo(){
return "こんにちは!";
}

//月の数字を格納した変数
const month = 1;

//テンプレート文字列の中で関数の呼び出しと掛け算を実行
const message = `皆さん${sayHallo()}。今日から${month*3}月です。`;

console.log(message); // 皆さんこんにちは。今日から３月です。

このように文字列内で Javascript の値を扱う時はテンプレート文字列を使用するようにしていくと良いでしょう。

# アロー関数 () => {}

アロー関数は ES2015 で追加された新しい関数の記述です。従来よりもシンプルに関数を記述することができます。また、書き方以外にも細かな違いがいくつかあるのですが本書では記法にフォーカスして解説します。

## 従来の関数

まずは従来の関数を振り返ってみます。以下は「引数として受け取った値をそのまま返却する関数を実行しコンソールに結果を出力する」という例です。

例：従来の関数（使用例１）
//従来の関数を定義
function func1(value){
return value;
}

//実行した結果を出力
console.log(func1("func1 です")); // func1 です

このように従来は Javascript で関数を定義する場合、function という記述のあとに関数名や引数、処理内容を記述していました。また、以下のように宣言した関数を一度変数に格納してから実行することもできます。

例：従来の関数（使用例２）
//従来の関数を定義
const func1 = function(value){
return value;
}

//実行した結果を出力
console.log(func1("func1 です")); // func1 です

結果は同じですが、いずれにせよ function という宣言を用いて関数を定義し実行していました。

## アロー関数

新たな関数の定義方法であるアロー関数では function は使用せず以下のように関数を宣言できます。

例：アロー関数
//アロー関数を定義
const func2 = (value) => {
return value;
};

//実行した結果を出力
console.log(func2("func2 です")); //func2 です

function という宣言はなくなり、いきなり()の中に引数を書き、「アロー関数」という名前の所以でもある=>という記号（矢印に見えることから）で関数を記述します。それ以降波カッコで処理を書く部分は同じです。
このようにより簡潔に関数を書くことができるようになりましたが、慣れるまでは意外と読みづらかったりするので、まずは=>が出てきたら「あ、関数だな」と思うようにすると良いです。

## アロー関数の書き方の注意点

アロー関数には特徴的な省略記法がいくつかあります。１つ目は引数が１つの場合はカッコを省略できるという点です。以下の例を見て下さい。

例：アロー関数の省略記法
//アロー関数を定義　＊引数が１つなのでカッコを省略
const func2 = value => {
return value;
};

//実行した結果を出力
console.log(func2("func2 です")); // func2 です

このように引数のカッコを省略しても正常に実行されます。実際のプロジェクトではコード整形ツールの prettier 等を使用してどちらかのルールに統一することが一般的ですが、どちらの書き方も可能だという事は覚えておきましょう。引数が２つ以上の場合は省略することが出来ません。

例：引数が２つ以上の場合
// 引数が２つ以上だとエラー
const func3 = value1. value2 => {
return value1 + value2;
};

//２つ以上の場合はカッコで囲む
const func3 = (value1,value2) => {
return value1 + value2;
};

２つ目は処理を単一行で返却する場合は波カッコと return を省略できるという点です。以下の例を見て下さい。

例：return の省略
//処理を単一行で返すので{}を省略
const func4 = (num1,num2) => num1 + num2;

//実行した結果を出力
console.log(func4(10,20)); // 30

上記のようにワンラインで関数を記述することができます。この記述はルールを知っていないとコードの意味が分からないかと思います。たまに勘違いして、以下のように波カッコで囲った中で return を省略してしまう人がいますが、これでは値が返却されないため注意が必要です。

例：誤った return の省略
//{}で囲ったのに return を書いていない
const func4 = (num1,num2) => {
num1 + num2;
}

//実行した結果を出力(何も表示されない)
console.log(func4(10,20)); // undefined

また返却値が複数行に及ぶ場合には、()で囲むことで単一行のようにまとめて返却することができるため以下のような書き方ができます。

例：()を用いて１行としてまとめる
// カッコで囲んでまとめて省略して返却
const func5 = (val1,val2) => {
{
name:val1,
age:val2,
}
}

//実行した結果を出力
console.log(func5("田中",24)); // {name:"田中".age:24}

この書き方は React を書いていく中でも使う機会が多いので、まずは上記のコードを見てパッと意味が分かるようにしておきましょう。

#　分割代入{}[]
ここでは分割代入について学びます。分割代入は、オブジェクトや配列から値を抽出するための方法です。
まずは分割代入を使用しない場合にどのように処理を書くことができるか見ていきます。プロフィール情報を格納したオブジェクトからテンプレート文字列の節で記述したような文字列を出力する以下のケースがあったとしましょう。

例：分割代入を使用しない文字列を出力
const myProfile = {
name:"田中",
age:24,
};

const message = `私の名前は${myProfile.name}です。年齢は${myProfile.age}才です`;
console.log(message); //私の名前は田中です。年齢は２４才です

このくらいであればまだギリギリ大丈夫ですが。オブジェクトのプロパティの数が多かったり、オブジェクトの変数名がもっと長いと毎回 myProfile.-と書くのが非常に冗長になります。そこで分割代入を使用します。

## オブジェクトの分割代入

分割代入を用いると上記と同じ処理を以下のように書くことができます。

例：分割代入を使用
const myProfile = {
name:"田中",
age:24,
};

//オブジェクトの分割代入
const {name,age} = myProfile;
const message = `私の名前は${name}です。年齢は${age}です`;
console.log(message); // 私の名前は田中です。年齢は２４才です

{}を変数宣言部に使用することでオブジェクト内から一致するプロパティを取り出すことができます。存在しないプロパティ名は指定できません。名称さえ合っていれば一部のみ取り出したり、順番が違ったりしても大丈夫です。

例：一部のみ取り出す
//一部のみ取り出す
const {age} = myProfile;

例：順番を変えて取り出す
//どんな順番でも大丈夫
const {age,name} = myProfile;

また、抽出したプロパティに別名をつけたい場合は以下のように:(コロン)を使用することでその変数名で扱うことも可能です。

例：抽出したプロパティに別名をつける
const myProfile = {
name:"田中",
age:24
};

//コロンで別の変数名を使用
const {name:newName,age:newAge} = myProfile;

const message = `私の名前は${newName}です。年齢は${newAge}才です`;
console.log(message); //私の名前は田中です。年齢は２４才です

オブジェクト内の値を使っていく場合は分割代入を用いてよりシンプルにできないか考えてみると良いでしょう。

## 配列の分割代入

オブジェクトと同様、配列に対しても分割代入を使うことができます。こちらもまずは一般的な方法を見てみます。

例：配列のインデックスを指定して代入を行う
const myProfile = ["田中",24];

const message = `私の名前は${myProfile[0]}です。年齢は${myProfile[1]}です`;
console.log(message); //私の名前は田中です。年齢は２４才です

上記の例は配列のそれぞれの要素にインデックスでアクセスして値を表示してます。こちらも分割代入を用いて同じ処理を以下のように書くことができます。

例：配列に対して分割代入を行う
const myProfile = ["田中",24];

//配列の分割代入
const [name,age] = myProfile;

const message = `私の名前は${name}です。年齢は${age}才です`;
console.log(message); //私の名前は田中です。年齢は２４才です

配列の分割代入の場合、変数宣言部に[]を使用し、配列に格納されている順番に任意の変数名を設定して抽出することができます。オブジェクトの時と異なり順番の入替はできず、自分で任意に設定した変数名を使用することになります。インデックスの途中までしか必要ない場合等は以降の要素を省略することはできます。

例：配列の必要な要素のみを取り出す
//１つ目のみ必要な場合
const [name] = myProfile;

以上のように分割代入を用いて要素の抽出を効率的に行えます。シンプルな機能ですが React 開発で非常によく使う事になるため覚えておいてください。オブジェクトと配列で微妙にルールが違ったりする点も注意しましょう。

## デフォルト値

デフォルト値の設定は、関数の引数やオブジェクトの分割代入時に使用します。値が存在しない場合の初期値を設定することが可能になり、より安全に処理を行うことができます。

# 引数のデフォルト値

まずは以下のような名前を受け取ってメッセージを表示する関数があるとしましょう。

例：メッセージを出力する関数
const sayHallo = (name) => console.log(`こんにちは！${name}さん！`);
sayHallo("田中"); //こんにちは！田中さん！

渡された名前を設定してコンソールに出力するだけの単純な関数です。ここで、sayHallo 関数を実行する時に引数が渡されなかった場合はどうなるでしょうか。

例：実行時に引数を渡さなかった場合
const sayHallo = (name) => console.log(`こんにちは！${name}さん！`);

sayHallo(); //こんにちは！undefined さん！

「こんにちは！undefined さん！」となってしまいました。Javascript では値が存在しない場合は undefined が設定されるためこのようにユーザーには意味が分からないメッセージが表示されてしまいます。
そこでデフォルト値を設定することで引数が渡されなかった場合に使用する値を記述できます。あくまでデフォルト値なので、何か値が渡された場合はそちらが優先されます。以下の例を見てみましょう。

例：デフォルト値の設定
const sayHallo = (name = "ゲスト") => console.log(`こんにちは！${name}さん！`);

sayHallo(); //こんにちは！ゲストさん！
sayHallo("田中"); //こんにちは！田中さん！

引数名の後ろに＝で値を記述することでデフォルト値を使用できます。引数を設定せずに sayHallo 関数を実行した場合、先ほどは undefined と表示されていましたが、設定後は「ゲスト」という文字列になっていることが確認できます。
このように渡されない可能性がある引数が存在する場合、デフォルト値を効果的に使うことができます。

# オブジェクト分割代入のデフォルト値

オブジェクトの分割代入時にもデフォルト値を使用することができます。以下のような処理があったとしましょう。

例：存在しないプロパティを出力
// name を削除
const myProfile = {
age:24;
}

// 存在しない name
const {name} = myProfile;

const message = `こんにちは！${name}さん！`;
console.log(message); //こんにちは！undefined さん！

そこで分割代入時にデフォルト値を設定することで以下のように処理を行うことができます。

例：分割代入時にデフォルト値を設定

```
const myProfile = {
 age: 24,
}

const {name = "ゲスト"} = myProfile;
const message = `こんにちは${name}さん！`
console.log(message); //こんにちは！ゲストさん！

```

引数の時と同様、変数名の後ろに＝で値を設定しておくと、プロパティが存在しない場合に設定する値を指定できます。オブジェクトの場合ももちろんプロパティが存在する場合はそちらが優先されます。
デフォルト値は React の開発でもよく使うのでマスターしておきましょう。

## スプレッド構文...

続いてスプレッド構文について見ていきましょう。スプレッド構文は配列やオブジェクトに対して使える記法でいくつかの使い道があります。

# 要素の展開

配列を１つ用意しましょう。

例：配列

```
const arr1 = [1,2];
console.log(arr1); // [1,2]
```

スプレッド構文は...とう形でドットを３つ繋げて使用します。配列に対して使用することで内部の要素を順番に展開してくれます。

書式　スプレッド構文

```
const arr1 = [1,2];
console.log(arr1); // [1,2]
console.log(...arr1); // 1 2
```

このように配列が展開されたので１，２という配列内の値が結果に出力されます。もう少し分かりやすい例を見てみましょう。

２つの引数を合計して出力する関数がある場合に、一般的な関数とスプレッド構文を用いた方法との比較です。

例：一般的な関数とスプレッド構文との比較

```
const arr1 = [1,2];
const summaryFunc = (num1, num2) => console.log(num1 + num2);

//普通に配列の値を渡す場合
summaryFunc(arr1[0], arr1[1]); //3

//スプレッド構文を用いた方法
summaryFunc(...arr1); //3
```

いかがでしょう。配列内部の値を「順番に展開」してくれるため簡潔に書けることが分かります。

# 要素をまとめる

スプレッド構文は「要素をまとめる」というニュアンスでも使用することができます。配列の分割代入の例が分かりやすいので、以下のコードを見てみましょう。

例：要素をまとめる

```
const arr2 = [1,2,3,4,5];

//分割代入時に残りを「まとめる」
const [num1, num2, ...arr3] = arr2;

console.log(num1); //1
console.log(num2); //2
console.log(arr3);  //[3,4,5]
```

先ほどの展開とは微妙に使い方が異なりますが、こういった使い方もできます。

# 要素のコピー、結合

ここからはこれまでの機能の応用的な使い方になります。よく使用される配列やオブジェクトのコピー、結合におけるスプレッド構文を紹介します。
以下のような２つの配列があるとしましょう。

例；２つの配列

```
const arr4 = [10, 20];
const arr5 = [30, 40];
```

この arr4 をコピーした新たな配列をスプレッド構文を用いて生成する場合、以下のような書き方ができます。

例：スプレッド構文を用いて新たな配列を生成

```
const arr4 = [10, 20];
const arr5 = [30, 40];

//スプレッド構文でコピー
const arr6 = [...arr4];

console.log(arr4); // [10,20]
console.log(arr6); // [10,20]
```

...で順番に展開して、配列で囲んでいるので結果的に新しい配列が出きるという理屈です。
応用で２つの配列の結合も以下のように行えます。

例：２つの配列の結合

```
//スプレッド構文で結合
const arr7 = [...arr4, ...arr5];

console.log(arr7); // [10,20,30,40]
```

コピーと同じ理屈で、複数の配列を展開することで結合も簡単に表現可能です。上記のコピーや結合はもちろんオブジェクトに対して使用することもできます。

例：複数のオブジェクトの結合

```
//スプレッド構文でコピー
const obj6 = {...obj4};

//スプレッド構文で結合
const obj7 = {...obj4, ...obj5};

console.log(obj6) // {val1: 10, val2: 20}
console.log(obj7); // {val1: 10,val2: 20,val3: 30,val4: 40}
```

#　なぜ＝でコピーしてはいけないのか

わざわざスプレッド構文でコピーしなくても＝でコピーすれば良いのでは？と思った方もいるかもしれません。確かに以下のようにすれば配列等のコピーは可能です。

例：　＝によるコピー

```
const arr4 = [10,20];

// =でコピー
const arr8 = arr4;

console.log(arr8); // [10,20]
```

しかしこの方法には問題があります。配列やオブジェクト等のオブジェクト型と呼ばれる変数はイコールでコピーすると<b>参照型も引き継がれてしまう</b>ため予期せぬ挙動が起きてしまうことがあります。
以下はイコールでコピーしたあとの配列に操作を加えたことでコピー元の配列にも影響が出てしまう例です。

例：コピーに起因する予期せぬ挙動

```
const arr4 = [10,20];

// =でコピー
const arr8 = arr4;

//arr8の最初の要素を１００に書き換える
arr8[0] = 100;

console.log(arr4); // [100,20]
console.log(arr8); // [100,20]
```

このようにコピー後の配列への操作がコピー元の配列にも影響を与えてしまっています。
ではスプレッド構文を用いたコピーの場合はどうでしょうか。

例：スプレッド構文を用いたコピー

```
//スプレッド構文でコピー
const arr8 = [...arr4];

console.log(arr4); // [10, 20]
console.log(arr8); // [100, 20]
```

スプレッド構文の場合は全く新しい配列を生成しているため元の配列に影響を与えることなく動作しています。
詳しくは React の基本で解説しますが、React 開発では値の変化に応じて画面を書き換えていくため、この全く新しい配列である。という判断を React 側が上手くできるように配列等に変化を加えるときもイコールでコピーではなくスプレッド構文でのコピー（新しい配列の生成）を使用しています（Splice 等の別の方法でも実装できます）。

## オブジェクトの省略記法

オブジェクトの記述の仕方で、使用頻度の高いショートハンド（省略記法）があります。それは<b>オブジェクトのプロパティ名と設定する変数名が同一の場合は省略できる</b>というものです。以下の例を見てみましょう。

例：プロパティ名と変数名が同一の場合 1

```
const name = "山田";
const age = "24";

//ユーザーオブジェクトを定義（プロパティ名はnameとage）
const user = {
    name:name,
    age:age,
};

console.log(user); // {name: "山田", age: 24}
```

上記はもっとも標準的な書き方でユーザー情報（name, age）を格納したオブジェクトを定義する例です。設定する値は事前に変数に格納してあります。
この例の場合プロパティ名と設定する変数名が同一なので以下のように記述することができます。

例：プロパティ名と変数名が同一の場合２

```
const name = "山田";
const age = 24;

//省略記法
const user = {
    name,
    age,
};

console.log(user); // {name: "山田" , age: 24}
```

オブジェクトの設定で：以降を省略し、１つにまとめることができました。オブジェクトの分割代入で別名をつける方法の逆のようなイメージですね。
この省略記法も頻繁に使って行くことになるので、覚えておきましょう。

# ESLint って何？

ここでは ESLint というものについて少し説明するよ！ESLint は動的解析ツールで、Prettier とセットで導入されることが多いよ。以下のようなコードの色んな問題をチェックすることができるからとっても便利！

・var での変数宣言をチェック  
・使っていない変数をチェック  
・残っている console.log をチェック  
・意味のない式をチェック　など

他にも React 特有のチェックを追加できたりするし、Prettier と同じでプロジェクトに合わせて色々カスタマイズできるからコードの品質を保つのに良いんだよ。２つセットで導入してみよう！

## map,filter

配列の処理で頻出する map と filter について紹介します。

# 従来の for 文

従来配列をループして処理する場合、for 文を使用していました。以下は名前が格納された配列をループして出力するサンプルです。

例：従来の for 文  
//配列を定義

```
const nameArr = ["山田","佐藤","後藤"];
//for文を使って配列処理
for(let index = 0; index < nameArr.length; index++){
    console.log(nameArr[index]);
}

//山田、佐藤、後藤
```

配列の要素の数分ループ処理を回して、ループ毎に index を１ずつ増加させ、配列の要素に index を用いてアクセスすることで順番に処理する仕組みです。構文も複雑で記述量もどうしても増えてしまいます。

# map 関数の使い方

では map 関数を使用するとどうなるか試してみましょう。map 関数では配列を順番に処理して処理した結果を配列として受け取ることができます。どういうことか順にコードを書いていきましょう。

例：配列 .map() step1  
//配列を定義

```
const nameArr = ["山田","佐藤","後藤"];

//配列　.map()として使用する
const nameArr2 = nameArr.map();

```

まず map 関数は配列に対して、配列 .map()という形で使用していきます。

例：配列 .map() step2

```
const nameArr = ["山田","佐藤","後藤"];

//配列 .map()として使用する
const nameArr2 = nameArr.map(() => {});
```

そして（）の中には関数を書きます。上記はアロー関数の雛形をまず記述したところです。関数は任意の名前をつけた引数をとることができ、そこに配列の中の値が入っていきます。そして返却する関数内で return します。

例：配列 .map() step3

```
const nameArr = ["山田","佐藤","後藤"];

//引数（name）に配列の値が設定される。returnで返却する
const nameArr2 = nameArr.map((name) => {
    return name;
})
console.log(nameArr2); // {"山田","佐藤","後藤"}　　
```

上記は順に処理する中で値をそのまま返しているので、同じ配列が設定されているという無意味な処理ですが、これが基本的な map の使い方です。では最初の for 文の例を map 関数で書き換えてみましょう。

例：map 関数を使用

```
const nameArr = ["山田","佐藤","後藤"];

//mapを使って配列処理
nameArr.map((name) => console.log(name));

//山田、佐藤、後藤
```

アロー関数を１行で書いてコンソールへの出力を記述しています。for 文の時と比べても非常にシンプルに書けることが分かると思います。返却値として配列を受け取る必要がない場合は上記のように新しい配列を定義せず単純にループ処理を行うこともできます。

filter 関数の使い方

では次に map 関数と似た filter 関数を見ていきましょう。filter 関数は map 関数とほとんど使い方が同じですが、return の後に条件式を記述して一致するもののみが返却される関数となります。
以下は数字が格納された配列から奇数のみ取り出す例です。

例：filter 関数で奇数のみ取り出す
//配列を定義

```
const numArr = [1,2,3,4,5];

//奇数（２で割った余りが１）のみ抽出
const newNumArr = numArr.filter((num) => {
    return num % 2 === 1;
});

console.log(newNumArr); // [1,3,5]
```

このように filter 関数は条件に一致する値のみ配列の中から取り出すことができます。プログラムを書いていて、配列の中から特定の条件に一致するものを取り出して処理したいというときは filter 関数を使っていきましょう。

# index の扱い

配列をループで処理する場合、何番目の要素かということを意識したいケースはよくあります。例えば従来の for 文の場合そもそも index を使用しているため、以下のようにすることで順序の概念も取り扱えます。

例：for 文の index で配列の要素を取り出す

```
const nameArr = ["山田","佐藤","後藤"];

//定義済みのindexを使用
for(let index = 0; index < nameArr.length; index++){
    console.log(`${index + 1}番目は ${nameArr[index]}です`);
}
//１番目は山田です
２番目は佐藤です
３番目は後藤です

```

テンプレート文字列で出力している部分は皆さんならもう苦も無く読めるかと思います。index が０から始まっているため+1 して出力しています。では、同じ処理を map 関数で実現してみましょう。ポイントとなるのは map()内で実行する関数の引数です。

例：map 関数の引数で要素順を取り出す

```
const nameArr = ["山田","佐藤","後藤"];

//第２引数にindexが入ってくる
nameArr.map((name, index) => console.log(` ${index +1} 番目は ${name}です`))
//１番目は山田です
２番目は佐藤です
３番目は後藤です
```

このように map 内の関数は第２引数を書くことができ、書いた場合はそこに０から順番に index の情報が格納されます。何番目かという概念が必要な場合は map や filter で第２引数を活用していきましょう。

# map を用いたサンプル

では最後に map 関数を用いた簡単な例をコーディングしてみましょう。仕様は以下とします。

仕様の説明  
山田、佐藤、後藤の名前が格納された配列がある。山田以外の名前には敬称であるさんを付与した新たな配列を生成する

仕様に対する実装例  
実装のパターンはいくつもありますが、map を用いた１つの答えの例はこうなります。

例：map を用いた上記仕様の実装例

```
const nameArr = ["山田","佐藤","後藤"];

const newNameArr = nameArr.map((name) => {
    if(name === "山田"){
        return name;
    }else{
        return `${name}さん`;
    }
});

console.log(newNameArr);
```

name が山田の場合はそのまま返却、それ以外の場合は末尾にさんを付与することで仕様を満たしています。このように配列の値を順番に扱っていくことで様々な操作が可能となります。
また React では画面表示の際にも頻繁に map を使用していくことになります。詳しくは React の章で解説していくので楽しみにしておいてください。

## おまけ：三項演算子

モダンな記法という訳ではないですが、React で使用することが多いので三項演算子についても解説しておきます。複雑に使いすぎると可読性が下がって良くないのですが、わざわざ if ～ else と書く手間が省けるケースもあるため適材適所で使えるようになりましょう。
構文としては以下のイメージになります。
